## Hash :smoking:
[toc]

###  1. HashTable(哈希表)

* 根据键(Key)而直接访问在内存存储位置的数据结构。通过计算一个关于键值的函数，将所需查询的数据映射到表中的一个位置来访问记录，加快了查找速度。(散列函数，散列表)
* 冲突(Collision):对不同的关键字可能得到同一散列地址,即$k_1\not=k_2$，而$f(k_1)=f(k_2)$。(同义词，散列造表，散列，散列地址)
* 均匀散列函数(Uniform Hash function):对于关键字的任一个关键字，经散列函数映像到地址集合中任何一个地址的概率是相等的。
* 构造散列函数:
	* 直接定址法:取关键字或者关键字的某个线性函数值为散列地址。即$hash(k)=k$或$hash(k)=a\cdot k+b$，其中$a,b$为常数。
	* 数学分析法:关键字事先知道的，则可取关键字的若干数位组成哈希地址。
	* 平方取中法:去关键字平方后的中间几位为哈希地址，位数由表长决定。
	* 折叠法:关键字分割成位数相同的几部分，然后取叠加和
	* 随机数法
	* 除留余数法:取关键字被某个不大于散列表表厂m的数p所得的余数为散列地址。即$hash(k)=k\bmod p,p\leq m$。不仅可以对关键字直接取模，也可以在折叠法，平方根法中等运算之后取模。对p的选择很重要，一般取素数或m。
* 冲突处理
	* 开放定址法(open addressing):$hash_i=(hash(key)+d_i)\bmod m,i=1,2,...k(k\leq m-1)$，其中$hash(key)$为散列函数，m为散列表长，$d_i$为增量序列,i为已发生冲突的次数。增量序列的取法:
		* $d_i=1,2,3...(m-1)$称为线性探测(Linear Probing)；即$d_i=i$,或者为其他线性函数。相当于逐个探测存放地址的表，直到查到一个空单元。
		* $d_i=\pm1^2,\pm2^2,\pm3^2...\pm k^2(k\leq m/2)$称为平方探测(Quadratic Probing)。发生冲突时探测间隔$d_i=i^2$个单元的位置是否为空。
		* $d_i=$伪随机数序列,称为伪随机探测。  

	很简单，不举例子了:kissing_smiling_eyes:
	
* <font color='blue'>聚集</font>(Cluster)
	
	* 散列结果不均匀，形成区块，造成线性探测产生一次聚集(primary clustering) 的平方探测的二次聚集(secondary clustering)，需要多次查找才能解决冲突。尤其是在开放定址法。
		* 单独链表法:链表存储冲突元素
		* 双散列
		* 再散列:散列后继续散列，直至没有冲突，不易产生Cluster，但增加了计算时间
		* 建立一个公共溢出区域
* 查找效率 
	* 与冲突多少有关
	* 影响冲突产生的因素:散列函数时候均匀，处理冲突的方法，散列表的载荷因子(load factor )
	* $\alpha=$填入表中的元素个数/散列长度。0.7-0.8以下
### 2. HashMap





